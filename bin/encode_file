#!/usr/bin/env ruby

# encode_file -k "key_file_name" -s "source_to_encode" -d "destination_file"

require "openssl"
require "digest"
require "trollop"
require "tempfile"

BLOCKSIZE_TO_READ = 1024 * 1000

opts = Trollop::options do
  opt :key_name, "Encryption Key", :type => :string
  opt :source_to_encode, "Path to target file for encryption.", :type => :string
  opt :destination_file, "Destination path for encrypted file."
end

Trollop::die "key_name and source_to_encode required" if !opts[:key_name] || !opts[:source_to_encode]
Trollop::die :key_name, "must exist" unless File.exist?(opts[:key_name]) if opts[:key_name]
Trollop::die :source_to_encode, "must exist" unless File.exist?(opts[:source_to_encode]) if opts[:source_to_encode]

def aes256_encrypt(key, file_path, output_path)
  key = Digest::SHA256.digest(key) if(key.kind_of?(String) && 32 != key.bytesize)
  aes = OpenSSL::Cipher.new('AES-256-CBC')
  aes.encrypt
  aes.key = key
  if output_path.nil?
    File.open(file_path, "rb") do |fi|
      while buffer = fi.read(BLOCKSIZE_TO_READ)
        $stdout.write(aes.update(buffer))
      end
      $stdout.write(aes.final)
    end
  else
    encrypt_file = Tempfile.new("encode")
    File.open(encrypt_file, "wb") do |ef|
      File.open(file_path, "rb") do |fi|
        while buffer = fi.read(BLOCKSIZE_TO_READ)
          ef.write(aes.update(buffer))
        end
      end
      ef.write(aes.final)
    end
    ::FileUtils.mv(encrypted_file.path, output_path)
  end
end

key = (File.read(opts[:key_name])).strip
if opts[:destination_file]
  aes256_encrypt(key,opts[:source_to_encode], opts[:destination_file])
else
  aes256_encrypt(key,opts[:source_to_encode], nil)
end
